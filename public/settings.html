<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>⚙ WebDAV Server - Settings</title>
  <link rel="stylesheet" href="/setting/css/settings.css">
  <!-- favicons: add both /icons and /setting/icons paths to match server static routing -->
  <link rel="icon" type="image/svg+xml" href="/icons/favicon.svg">
  <link rel="icon" type="image/svg+xml" href="/setting/icons/favicon.svg">
  <link rel="shortcut icon" href="/setting/icons/favicon.svg">
  <!-- fallback (webp/png) if available -->
  <link rel="alternate icon" type="image/png" href="/icons/favicon-256.png">
  <link rel="alternate icon" type="image/png" href="/setting/icons/favicon-256.png">
  <link rel="alternate icon" type="image/webp" href="/icons/favicon-256.webp">
  <link rel="alternate icon" type="image/webp" href="/setting/icons/favicon-256.webp">
  <style>
  /* Toggle switch minimal styles (kept inline for small feature) */
  .checkbox-row { display:flex; align-items:center; gap:8px; }
  .checkbox-row label { margin:0; }
  .checkbox-row input[type="checkbox"] { display:none; }
  .checkbox-row .switch { display:inline-block; width:44px; height:24px; background:var(--switch-off-bg); border-radius:999px; position:relative; transition:background .15s ease; margin-left:8px; }
  .checkbox-row .switch::after { content:''; position:absolute; left:3px; top:3px; width:18px; height:18px; background:var(--switch-knob); border-radius:50%; box-shadow:0 1px 2px rgba(0,0,0,0.2); transition:transform .15s ease; }
  .checkbox-row .switch.on { background:var(--switch-on-bg); }
  .checkbox-row .switch.on::after { transform:translateX(20px); }
  .checkbox-row .switch:focus { outline:2px solid rgba(0,0,0,0.12); outline-offset:3px; }
  </style>
</head>
<body>
  <div class="container">
    <h1>WebDAV Server — 設定画面</h1>
  <!-- <div class="header-row">
      <div class="lead">フォームで設定を編集できます。各項目の説明を参照の上、編集してください。編集後は <strong>保存</strong> を押して反映します。</div>
      <div class="header-actions">
      </div>
    </div> -->

    <div class="grid">
      <div class="card">
        <form id="settingsForm" autocomplete="off">
          <div class="field-group">
            <h3>圧縮設定</h3>
            <div class="row checkbox-row">
              <label for="COMPRESSION_ENABLED">レスポンス圧縮を有効にする</label>
              <input id="COMPRESSION_ENABLED" name="COMPRESSION_ENABLED" type="checkbox" />
            </div>
            <div class="row">
              <label for="COMPRESSION_THRESHOLD">圧縮閾値 (0.0〜1.0)</label>
              <div class="field-control">
                <input id="COMPRESSION_THRESHOLD" name="COMPRESSION_THRESHOLD" type="range" step="0.01" min="0" max="1" />
                <output id="COMPRESSION_THRESHOLD_VAL" for="COMPRESSION_THRESHOLD">0.00</output>
              </div>
            </div>
            <!-- <div class="desc">テキスト系レスポンスを gzip 圧縮するか。閾値は圧縮後サイズ ÷ 元のサイズ（小さいほど圧縮が適用されやすい）。</div> -->
          </div>

          <div class="field-group">
            <h3>画像変換設定</h3>
            <div class="row">
              <label for="IMAGE_TEMPLATE">テンプレート</label>
              <select id="IMAGE_TEMPLATE" name="IMAGE_TEMPLATE">
                <option value="">未選択</option>
                <option value="small">最低画質</option>
                <option value="medium">中画質</option>
                <option value="large">高画質</option>
                <option value="hq">オリジナル画質</option>
              </select>
            </div>
            <div class="row">
              <label for="PHOTO_SIZE">最大画像サイズ (px)</label>
              <input id="PHOTO_SIZE" name="PHOTO_SIZE" type="number" min="16" inputmode="numeric" pattern="[0-9]*" />
            </div>
            <div class="row">
              <label for="DEFAULT_QUALITY">品質（1〜100）</label>
              <div class="field-control">
                <input id="DEFAULT_QUALITY" name="DEFAULT_QUALITY" type="range" step="1" min="1" max="100" />
                <output id="DEFAULT_QUALITY_VAL" for="DEFAULT_QUALITY">50</output>
              </div>
            </div>
            <div class="row">
              <label for="IMAGE_MODE">画像処理モード</label>
              <select id="IMAGE_MODE" name="IMAGE_MODE">
                <option value="1">1 — 高速（低負荷）</option>
                <option value="2">2 — バランス（推奨）</option>
                <option value="3">3 — 高品質（高負荷）</option>
              </select>
            </div>
            <!-- <div class="desc">画像のリサイズ上限(px)、デフォルトの出力品質、処理モードを設定</div> -->
          </div>

          <div class="field-group">
            <h3>キャッシュ / メモリ</h3>
            <div class="row">
              <label for="CACHE_TTL_MS">キャッシュ有効期限 (秒)</label>
              <input id="CACHE_TTL_MS" name="CACHE_TTL_MS" type="number" min="0" inputmode="numeric" pattern="[0-9]*" />
            </div>
            <div class="row">
              <label for="CACHE_MIN_SIZE">キャッシュ対象の最小サイズ (KB)</label>
              <input id="CACHE_MIN_SIZE" name="CACHE_MIN_SIZE" type="number" min="0" inputmode="numeric" pattern="[0-9]*" />
            </div>
            <div class="row">
              <label for="MAX_CONCURRENCY">同時処理数の上限（1〜32）</label>
              <div class="field-control">
                <input id="MAX_CONCURRENCY" name="MAX_CONCURRENCY" type="range" step="1" min="1" max="32" />
                <output id="MAX_CONCURRENCY_VAL" for="MAX_CONCURRENCY">4</output>
              </div>
            </div>
            <div class="row">
              <label for="SHARP_MEMORY_LIMIT">Sharp メモリ制限 (128〜8192 MB)</label>
              <div class="field-control">
                <input id="SHARP_MEMORY_LIMIT" name="SHARP_MEMORY_LIMIT" type="range" step="1" min="128" max="8192" />
                <output id="SHARP_MEMORY_LIMIT_VAL" for="SHARP_MEMORY_LIMIT">512</output>
              </div>
            </div>
            <div class="row">
              <label for="SHARP_PIXEL_LIMIT">Sharp ピクセル上限</label>
              <input id="SHARP_PIXEL_LIMIT" name="SHARP_PIXEL_LIMIT" type="number" min="0" max="50000000" inputmode="numeric" pattern="[0-9]*" />
            </div>
            <!-- <div class="desc">画像変換キャッシュの設定や Sharp ライブラリのメモリ・処理上限を調整</div> -->
          </div>

          <div class="field-group">
            <h3>サーバー設定</h3>
            <div class="row">
              <label for="PORT">待ち受けポート番号</label>
              <input id="PORT" name="PORT" type="number" min="1" max="65535" inputmode="numeric" pattern="[0-9]*" />
            </div>
            <div class="row">
              <label for="ROOT_PATH">サーバー ルートパス</label>
              <input id="ROOT_PATH" name="ROOT_PATH" type="text" />
            </div>
            <div class="row">
              <label for="MAX_LIST">ディレクトリ一覧の最大件数</label>
              <input id="MAX_LIST" name="MAX_LIST" type="number" min="1" inputmode="numeric" pattern="[0-9]*" />
            </div>
            <!-- <div class="desc">サーバーの待ち受けポート、WebDAV のルートフォルダ、ディレクトリ一覧で表示する最大件数を指定</div> -->
          </div>

          <div class="field-group">
            <h3>レート制限</h3>
            <div class="row checkbox-row">
              <label for="RATE_LIMIT_ENABLED">レート制限を有効にする</label>
              <input id="RATE_LIMIT_ENABLED" name="RATE_LIMIT_ENABLED" type="checkbox" />
            </div>
            <div class="row">
              <label for="RATE_LIMIT_REQUESTS">許可リクエスト数</label>
              <input id="RATE_LIMIT_REQUESTS" name="RATE_LIMIT_REQUESTS" type="number" min="0" inputmode="numeric" pattern="[0-9]*" />
            </div>
            <div class="row">
              <label for="RATE_LIMIT_WINDOW_MS">リクエスト生存時間 (秒)</label>
              <input id="RATE_LIMIT_WINDOW_MS" name="RATE_LIMIT_WINDOW_MS" type="number" min="0" inputmode="numeric" pattern="[0-9]*" />
            </div>
            <div class="row">
              <label for="RATE_LIMIT_QUEUE_SIZE">レート制限キューサイズ</label>
              <input id="RATE_LIMIT_QUEUE_SIZE" name="RATE_LIMIT_QUEUE_SIZE" type="number" min="0" inputmode="numeric" pattern="[0-9]*" />
            </div>
            <!-- <div class="desc">大量アクセス対策の設定です。負荷状況に応じて調整してください。</div> -->
          </div>

          <div class="field-group">
            <h3>緊急 / スタック / 再起動</h3>
            <div class="row checkbox-row">
              <label for="EMERGENCY_DISABLE_RATE_LIMIT">緊急時にレート制限を無効化する</label>
              <input id="EMERGENCY_DISABLE_RATE_LIMIT" name="EMERGENCY_DISABLE_RATE_LIMIT" type="checkbox" />
            </div>
            <div class="row">
              <label for="STACK_MAX_SIZE">スタック最大サイズ</label>
              <input id="STACK_MAX_SIZE" name="STACK_MAX_SIZE" type="number" min="1" inputmode="numeric" pattern="[0-9]*" />
            </div>
            <div class="row">
              <label for="STACK_PROCESSING_DELAY_MS">スタック処理遅延 (ms)</label>
              <input id="STACK_PROCESSING_DELAY_MS" name="STACK_PROCESSING_DELAY_MS" type="number" min="0" inputmode="numeric" pattern="[0-9]*" />
            </div>
            <div class="row checkbox-row">
              <label for="RESTART_ENABLED">自動再起動を有効にする</label>
              <input id="RESTART_ENABLED" name="RESTART_ENABLED" type="checkbox" />
            </div>
            <div class="row">
              <label for="RESTART_TIME">自動再起動時刻 (HH:MM)</label>
              <input id="RESTART_TIME" name="RESTART_TIME" type="text" pattern="^\\d{1,2}:\\d{2}$" />
            </div>
            <!-- <div class="desc">緊急時の動作やスタック処理、定期的な自動再起動の設定を行います。</div> -->
          </div>

          <div class="field-group">
            <h3>その他</h3>
            <div class="row">
              <label for="MAGICK_PATH">ImageMagick コマンド / パス</label>
              <input id="MAGICK_PATH" name="MAGICK_PATH" type="text" />
            </div>
            <!-- <div class="desc">ImageMagick を使用する場合のコマンド名またはフルパス。未設定時は既定のコマンド名を使用します。</div> -->
          </div>
          <div class="field-group">

          <!--
          <div class="actions">
            <button type="button" id="btnLoad" class="btn-ghost">再読み込み</button>
            <button type="button" id="btnSave">保存</button>
            <button type="button" id="btnRaw">生データ表示切替</button>
            <div class="status" id="status"></div>
          </div>
          -->

        </form>
      </div>

      <!--
      <div class="card">
        <h3>項目説明</h3>
        <div class="small">
          このパネルでは各設定項目の簡単な説明を表示します。フォームで値を変更して <strong>Save</strong> を押すとサーバ上の <code>config.txt</code> を上書きします。運用中は必ずバックアップを取ってから変更してください。
        </div>

  <hr />

        <div id="help" class="small">
          <strong>COMPRESSION_ENABLED</strong><br/>テキスト系レスポンスの gzip 圧縮を有効にします。<br/><br/>
          <strong>COMPRESSION_THRESHOLD</strong><br/>圧縮後のサイズ比 (compressed / original)。小さいほど圧縮が適用されやすくなります（例: 0.3）。<br/><br/>
          <strong>PHOTO_SIZE</strong><br/>画像変換時の最大ピクセル幅/高さ（px）。<br/><br/>
          <strong>IMAGE_MODE</strong><br/>処理モード。1=高速, 2=バランス, 3=高品質（品質と負荷のトレードオフ）。<br/><br/>
          <strong>CACHE_TTL_MS</strong><br/>キャッシュの有効期限（ミリ秒）。期限切れのキャッシュは定期的に削除されます。<br/><br/>
          <strong>SHARP_MEMORY_LIMIT</strong><br/>Sharp のメモリキャッシュ（MB）。システムの物理メモリに合わせて調整してください。<br/><br/>
          <strong>RATE_LIMIT_*</strong><br/>大量アクセス対策の設定（許可リクエスト数、ウィンドウ時間、キュー長など）。<br/>
        </div>

  <hr />

        <div>
          <h4>Raw content</h4>
          <pre id="raw" tabindex="0" role="region" aria-label="設定ファイルの生テキスト">読み込みしてください</pre>
        </div>

      </div>
      -->
    </div>
  </div>

  <!-- fixed save bar -->
  <div id="fixedBar" class="fixed-bar" aria-hidden="false">
    <div class="fixed-bar-inner">
      <button id="btnLoadFixed" class="btn-ghost" type="button">再読み込み</button>
      <button id="btnSaveFixed" class="btn-primary" type="button">保存</button>
      <div class="status" id="statusFixed"></div>
      <button id="themeToggle" class="btn-ghost" type="button">ダーク</button>
    </div>
  </div>

  <script>
    // mapping between form fields and config keys
    const keys = [
      'COMPRESSION_ENABLED','COMPRESSION_THRESHOLD',
      'PORT','ROOT_PATH','MAX_LIST',
      'PHOTO_SIZE','DEFAULT_QUALITY','IMAGE_MODE',
      'CACHE_TTL_MS','CACHE_MIN_SIZE','MAX_CONCURRENCY','SHARP_MEMORY_LIMIT','SHARP_PIXEL_LIMIT',
      'RATE_LIMIT_ENABLED','RATE_LIMIT_REQUESTS','RATE_LIMIT_WINDOW_MS','RATE_LIMIT_QUEUE_SIZE',
      'EMERGENCY_DISABLE_RATE_LIMIT','STACK_MAX_SIZE','STACK_PROCESSING_DELAY_MS',
      'RESTART_ENABLED','RESTART_TIME','MAGICK_PATH'
    ];

    // convenience helpers
    const byId = id => document.getElementById(id);
    const statusEl = byId('status');
    const rawEl = byId('raw');
    const themeBtn = byId('themeToggle');
  // initial snapshot used for dirty checking
  let initialConfigText = null;

    // Theme helpers: apply and persist theme (light/dark)
    function applyTheme(theme){
      if (theme === 'dark') document.documentElement.setAttribute('data-theme','dark');
      else document.documentElement.removeAttribute('data-theme');
      try {
        if (themeBtn) themeBtn.textContent = theme === 'dark' ? 'ライト' : 'ダーク';
      } catch(e){}
    }

    function loadTheme(){
      try {
        const t = localStorage.getItem('settings_theme') || 'light';
        applyTheme(t);
      } catch(e){}
    }

    function toggleTheme(){
      try{
        const current = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'light';
        const next = current === 'dark' ? 'light' : 'dark';
        localStorage.setItem('settings_theme', next);
        applyTheme(next);
      }catch(e){}
    }

    function setStatus(msg, err) {
      try {
        if (!statusEl) return;
        statusEl.textContent = msg || '';
        statusEl.style.color = err ? 'var(--danger)' : '';
      } catch(e) {
        // ignore DOM write errors when status element is absent
      }
    }

    // parse config.txt into object {KEY: value}
    function parseConfig(text) {
      const out = {};
      const lines = text.split(/\r?\n/);
      for (const line of lines) {
        const t = line.trim();
        if (!t || t.startsWith('#')) continue;
        const idx = t.indexOf('=');
        if (idx === -1) continue;
        const k = t.slice(0, idx).trim();
        let v = t.slice(idx+1).trim();
        // keep as string; we'll interpret booleans/numbers in UI logic
        out[k] = v;
      }
      return out;
    }

    // populate form from config object
    function populateForm(cfg) {
      for (const k of keys) {
        const el = byId(k);
        if (!el) continue;
        const v = cfg[k];
        if (el.type === 'checkbox') {
          el.checked = (typeof v !== 'undefined') ? (String(v).toLowerCase() === 'true') : false;
        } else {
          el.value = (typeof v !== 'undefined') ? v : '';
        }
      }
      // show raw
      buildRaw();
      // Update compression slider display if present (ensure value reflects loaded config)
      try {
        const compSlider = byId('COMPRESSION_THRESHOLD');
        const compOut = byId('COMPRESSION_THRESHOLD_VAL');
        if (compSlider && compOut) {
          const n = Number(compSlider.value || 0);
          compOut.textContent = isNaN(n) ? '0.00' : n.toFixed(2);
        }
      } catch(e) {}
      // Convert CACHE_TTL_MS (stored in ms) to seconds for UI
      try {
        const el = byId('CACHE_TTL_MS');
        if (el) {
          const raw = cfg['CACHE_TTL_MS'];
          if (typeof raw !== 'undefined' && raw !== '') {
            const ms = Number(raw);
            if (!isNaN(ms)) el.value = String(Math.round(ms / 1000));
          }
        }
      } catch(e) {}
      // Convert CACHE_MIN_SIZE (stored in bytes) to KB for UI
      try {
        const el = byId('CACHE_MIN_SIZE');
        if (el) {
          const raw = cfg['CACHE_MIN_SIZE'];
          if (typeof raw !== 'undefined' && raw !== '') {
            const bytes = Number(raw);
            if (!isNaN(bytes)) el.value = String(Math.round(bytes / 1024));
          }
        }
      } catch(e) {}
      // Convert RATE_LIMIT_WINDOW_MS (stored in ms) to seconds for UI
      try {
        const el = byId('RATE_LIMIT_WINDOW_MS');
        if (el) {
          const raw = cfg['RATE_LIMIT_WINDOW_MS'];
          if (typeof raw !== 'undefined' && raw !== '') {
            const ms = Number(raw);
            if (!isNaN(ms)) el.value = String(Math.round(ms / 1000));
          }
        }
      } catch(e) {}
      // Update default quality display if present
      try {
        const qSlider = byId('DEFAULT_QUALITY');
        const qOut = byId('DEFAULT_QUALITY_VAL');
        if (qSlider && qOut) {
          const n = Number(qSlider.value || 50);
          qOut.textContent = isNaN(n) ? '50' : String(n);
        }
      } catch(e) {}
      // Update max concurrency display if present
      try {
        const mSlider = byId('MAX_CONCURRENCY');
        const mOut = byId('MAX_CONCURRENCY_VAL');
        if (mSlider && mOut) {
          const n = Number(mSlider.value || 4);
          mOut.textContent = isNaN(n) ? '4' : String(Math.round(n));
        }
      } catch(e) {}
      // Update Sharp memory limit display if present
      try {
        const sSlider = byId('SHARP_MEMORY_LIMIT');
        const sOut = byId('SHARP_MEMORY_LIMIT_VAL');
        if (sSlider && sOut) {
          const n = Number(sSlider.value || 512);
          sOut.textContent = isNaN(n) ? '512' : String(Math.round(n));
        }
      } catch(e) {}
      // sync checkbox-based toggle switches (if present) to the checkbox state
      try {
        document.querySelectorAll('input[type="checkbox"]').forEach(cb => {
          try {
            const row = cb.closest('.checkbox-row');
            if (!row) return;
            const sw = row.querySelector('.switch');
            if (!sw) return;
            if (cb.checked) sw.classList.add('on'); else sw.classList.remove('on');
            sw.setAttribute('aria-checked', cb.checked ? 'true' : 'false');
          } catch(e) {}
        });
      } catch(e) {}
    }

    // build raw config text from form values (with comments/header)
    function buildConfigText() {
      const header = [
        '# WebDAV画像変換サーバー設定ファイル (自動生成)',
        '# 編集はフォームで行ってください。'
      ];
      const lines = [...header];
      // group order similar to original file
      const add = (k) => {
        const el = byId(k);
        if (!el) return;
        let v;
        if (el.type === 'checkbox') v = el.checked ? 'true' : 'false';
        else if (k === 'CACHE_TTL_MS') {
          // UI shows seconds; convert back to milliseconds for config file
          const secs = Number(el.value || 0);
          v = String(Math.round((isNaN(secs) ? 0 : secs) * 1000));
        } else if (k === 'CACHE_MIN_SIZE') {
          // UI shows KB; convert back to bytes for config file
          const kb = Number(el.value || 0);
          v = String(Math.round((isNaN(kb) ? 0 : kb) * 1024));
        } else if (k === 'RATE_LIMIT_WINDOW_MS') {
          // UI shows seconds; convert back to milliseconds for config file
          const secs = Number(el.value || 0);
          v = String(Math.round((isNaN(secs) ? 0 : secs) * 1000));
        } else v = el.value ?? '';
        lines.push(`${k}=${v}`);
      };
      const groups = [
        ['COMPRESSION_ENABLED','COMPRESSION_THRESHOLD'],
        ['PORT','ROOT_PATH','MAX_LIST'],
        ['PHOTO_SIZE','DEFAULT_QUALITY','IMAGE_MODE'],
        ['CACHE_TTL_MS','CACHE_MIN_SIZE','MAX_CONCURRENCY','SHARP_MEMORY_LIMIT','SHARP_PIXEL_LIMIT'],
        ['RATE_LIMIT_ENABLED','RATE_LIMIT_REQUESTS','RATE_LIMIT_WINDOW_MS','RATE_LIMIT_QUEUE_SIZE'],
        ['EMERGENCY_DISABLE_RATE_LIMIT'],
        ['STACK_MAX_SIZE','STACK_PROCESSING_DELAY_MS'],
        ['RESTART_ENABLED','RESTART_TIME'],
        ['MAGICK_PATH']
      ];
      for (const g of groups) {
        lines.push(''); // blank line between groups
        for (const k of g) add(k);
      }
      return lines.join('\n') + '\n';
    }

    // build raw preview
    function buildRaw() {
      if (!rawEl) return;
      rawEl.textContent = buildConfigText();
    }

    // save-button enable/disable helpers
    function setSaveEnabled(enabled) {
      try {
        const btns = [];
        const a = byId('btnSave'); if (a) btns.push(a);
        const b = byId('btnSaveFixed'); if (b) btns.push(b);
        for (const btn of btns) {
          btn.disabled = !enabled;
          if (!enabled) btn.setAttribute('aria-disabled', 'true');
          else btn.removeAttribute('aria-disabled');
        }
      } catch(e){}
    }

    function checkDirty() {
      try {
        const cur = buildConfigText();
        const dirty = initialConfigText === null ? false : (cur !== initialConfigText);
        setSaveEnabled(dirty);
        return dirty;
      } catch(e){ return false; }
    }

    // validate simple constraints, returns {ok:bool, msg:...}
    function validate() {
      // example: port range
      const port = Number(byId('PORT').value || 0);
      if (!Number.isInteger(port) || port < 1 || port > 65535) return {ok:false,msg:'PORT は 1..65535 の整数で指定してください'};
      const q = Number(byId('DEFAULT_QUALITY').value || 0);
      if (!Number.isFinite(q) || q < 1 || q > 100) return {ok:false,msg:'DEFAULT_QUALITY は 1..100 で指定してください'};
      const pct = Number(byId('COMPRESSION_THRESHOLD').value || -1);
      if (!Number.isFinite(pct) || pct < 0 || pct > 1) return {ok:false,msg:'COMPRESSION_THRESHOLD は 0.0 〜 1.0 の値で指定してください'};
      // CACHE_TTL_MS is shown in seconds in the UI
      const cacheSecs = Number(byId('CACHE_TTL_MS').value || 0);
      if (!Number.isFinite(cacheSecs) || cacheSecs < 0) return {ok:false, msg:'CACHE_TTL_MS は 0 以上の秒数で指定してください'};
  // RATE_LIMIT_WINDOW_MS is shown in seconds in the UI
  const rateWindowSecs = Number(byId('RATE_LIMIT_WINDOW_MS').value || 0);
  if (!Number.isFinite(rateWindowSecs) || rateWindowSecs < 0) return {ok:false, msg:'RATE_LIMIT_WINDOW_MS は 0 以上の秒数で指定してください'};
      // CACHE_MIN_SIZE is shown in KB in the UI
      const cacheMinKb = Number(byId('CACHE_MIN_SIZE').value || 0);
      if (!Number.isFinite(cacheMinKb) || cacheMinKb < 0) return {ok:false, msg:'CACHE_MIN_SIZE は 0 以上の KB で指定してください'};
      return {ok:true};
    }

    // fetch config.txt content
    async function loadConfig() {
      setStatus('Loading...');
      try {
        const r = await fetch('/setting/data');
        if (!r.ok) throw new Error('HTTP ' + r.status);
        const j = await r.json();
        const txt = j.content || '';
        const statusLocal = byId('status');
        if (statusLocal) statusLocal.textContent = '';
        const cfg = parseConfig(txt);
        populateForm(cfg);
        // store snapshot for dirty checking
        initialConfigText = buildConfigText();
        checkDirty();
        setStatus('Loaded');
      } catch (e) {
        setStatus('Load error: ' + (e.message || e), true);
      }
    }

    // save config: build text and POST
    async function saveConfig() {
      setStatus('Validating...');
      const v = validate();
      if (!v.ok) { setStatus(v.msg, true); return; }
      const text = buildConfigText();
      // show raw preview before saving (only if raw preview exists)
      if (rawEl) rawEl.textContent = text;
      setStatus('Saving...');
      try {
        const r = await fetch('/setting/save', {
          method: 'POST',
          headers: {'Content-Type':'application/json'},
          body: JSON.stringify({ content: text })
        });
        if (!r.ok) throw new Error('HTTP ' + r.status);
        // update snapshot and disable save until next change
        initialConfigText = buildConfigText();
        setSaveEnabled(false);
        setStatus('Saved');
      } catch (e) {
        setStatus('Save error: ' + (e.message || e), true);
      }
    }

    // event wiring (guarded in case buttons are commented out)
    const btnLoadEl = document.getElementById('btnLoad');
    const btnSaveEl = document.getElementById('btnSave');
    const btnRawEl = document.getElementById('btnRaw');
    if (btnLoadEl) btnLoadEl.addEventListener('click', loadConfig);
    if (btnSaveEl) btnSaveEl.addEventListener('click', () => { saveConfig(); });
    if (btnRawEl) btnRawEl.addEventListener('click', () => {
      if (!rawEl) return; // raw preview intentionally removed/commented out
      rawEl.style.display = rawEl.style.display === 'none' ? 'block' : 'none';
    });
    if (themeBtn) themeBtn.addEventListener('click', toggleTheme);

    // initialize
    (function init(){
      // set some defaults
      for (const k of keys) {
        const el = byId(k);
        if (!el) continue;
        if (el.type === 'checkbox') el.checked = false;
        else el.value = '';
      }
      loadConfig();
      loadTheme();
      // initially disable save buttons until we have a snapshot
      setSaveEnabled(false);
      // wire change listeners to detect dirty state
      for (const k of keys) {
        const el = byId(k);
        if (!el) continue;
        const ev = (el.type === 'checkbox' || el.tagName.toLowerCase() === 'select') ? 'change' : 'input';
        el.addEventListener(ev, () => checkDirty());
      }
      // compression threshold slider wiring: update output and dirty state
      const compSlider = byId('COMPRESSION_THRESHOLD');
      const compOut = byId('COMPRESSION_THRESHOLD_VAL');
      function updateCompressionDisplay(v){
        const n = Number(v);
        if (isNaN(n)) { if (compOut) compOut.textContent = '0.00'; return; }
        if (compOut) compOut.textContent = n.toFixed(2);
      }
      if (compSlider) {
        // when populateForm sets the value, ensure display is updated
        compSlider.addEventListener('input', (e) => { updateCompressionDisplay(e.target.value); checkDirty(); });
        // initialize display from current value
        updateCompressionDisplay(compSlider.value || 0);
      }
      // DEFAULT_QUALITY slider wiring
      const qSlider = byId('DEFAULT_QUALITY');
      const qOut = byId('DEFAULT_QUALITY_VAL');
      function updateQualityDisplay(v){
        const n = Number(v);
        if (isNaN(n)) { if (qOut) qOut.textContent = '50'; return; }
        if (qOut) qOut.textContent = String(Math.round(n));
      }
      if (qSlider) {
        qSlider.addEventListener('input', (e) => { updateQualityDisplay(e.target.value); checkDirty(); });
        updateQualityDisplay(qSlider.value || 50);
      }
      // MAX_CONCURRENCY slider wiring
      const mSlider = byId('MAX_CONCURRENCY');
      const mOut = byId('MAX_CONCURRENCY_VAL');
      function updateMaxConcurrencyDisplay(v){
        const n = Number(v);
        if (isNaN(n)) { if (mOut) mOut.textContent = '4'; return; }
        if (mOut) mOut.textContent = String(Math.round(n));
      }
      if (mSlider) {
        mSlider.addEventListener('input', (e) => { updateMaxConcurrencyDisplay(e.target.value); checkDirty(); });
        updateMaxConcurrencyDisplay(mSlider.value || 4);
      }
      // SHARP_MEMORY_LIMIT slider wiring
      const sSlider = byId('SHARP_MEMORY_LIMIT');
      const sOut = byId('SHARP_MEMORY_LIMIT_VAL');
      function updateSharpMemoryDisplay(v){
        const n = Number(v);
        if (isNaN(n)) { if (sOut) sOut.textContent = '512'; return; }
        if (sOut) sOut.textContent = String(Math.round(n));
      }
      if (sSlider) {
        sSlider.addEventListener('input', (e) => { updateSharpMemoryDisplay(e.target.value); checkDirty(); });
        updateSharpMemoryDisplay(sSlider.value || 512);
      }
      // wire template selector
      const templateSelect = byId('IMAGE_TEMPLATE');
      const templates = {
        small: { PHOTO_SIZE: '640', DEFAULT_QUALITY: '30', IMAGE_MODE: '1' },
        medium: { PHOTO_SIZE: '1080', DEFAULT_QUALITY: '50', IMAGE_MODE: '2' },
        large: { PHOTO_SIZE: '1440', DEFAULT_QUALITY: '70', IMAGE_MODE: '2' },
        hq: { PHOTO_SIZE: '2400', DEFAULT_QUALITY: '85', IMAGE_MODE: '3' }
      };
      if (templateSelect) {
        templateSelect.addEventListener('change', (ev) => {
          const v = ev.target.value;
          if (!v) return; // no-op when clearing
          const t = templates[v];
          if (!t) return;
          // apply template values to form fields
          for (const k of Object.keys(t)) {
            const el = byId(k);
            if (!el) continue;
            el.value = t[k];
          }
          // programmatic changes don't fire input/change events in all browsers,
          // so update any UI-only displays (slider outputs) manually.
          try {
            if (typeof updateQualityDisplay === 'function' && qSlider) updateQualityDisplay(qSlider.value);
          } catch(e) {}
          try {
            if (typeof updateCompressionDisplay === 'function' && compSlider) updateCompressionDisplay(compSlider.value);
          } catch(e) {}
          // values changed programmatically — re-check dirty state
          try { checkDirty(); } catch(e) {}
        });
      }

      // wire fixed bar buttons (if present)
      const btnSaveFixed = byId('btnSaveFixed');
      const btnLoadFixed = byId('btnLoadFixed');
      const statusFixed = byId('statusFixed');
      if (btnSaveFixed) btnSaveFixed.addEventListener('click', () => saveConfig());
      if (btnLoadFixed) btnLoadFixed.addEventListener('click', () => loadConfig());
      // keep status in sync
      const origSetStatus = setStatus;
      setStatus = (msg, err) => {
        try {
          origSetStatus(msg, err);
        } catch(e) {}
        try {
          if (statusFixed) statusFixed.textContent = msg || '';
        } catch(e) {}
      };

      // convert checkbox rows into accessible visual toggle switches
      try {
        const checkboxRows = document.querySelectorAll('.checkbox-row');
        checkboxRows.forEach(row => {
          const cb = row.querySelector('input[type="checkbox"]');
          if (!cb) return;
          // avoid double-inserting
          if (row.querySelector('.switch')) return;
          const sw = document.createElement('span');
          sw.className = 'switch' + (cb.checked ? ' on' : '');
          sw.setAttribute('tabindex', '0');
          sw.setAttribute('role', 'switch');
          sw.setAttribute('aria-checked', cb.checked ? 'true' : 'false');
          // when switch clicked, toggle checkbox and fire events
          const toggle = () => {
            cb.checked = !cb.checked;
            // update visual
            if (cb.checked) sw.classList.add('on'); else sw.classList.remove('on');
            sw.setAttribute('aria-checked', cb.checked ? 'true' : 'false');
            // emit change event for existing listeners
            try { cb.dispatchEvent(new Event('change', { bubbles: true })); } catch(e) {}
            try { checkDirty(); } catch(e) {}
          };
          sw.addEventListener('click', (e) => { e.preventDefault(); toggle(); });
          sw.addEventListener('keydown', (e) => {
            if (e.key === ' ' || e.key === 'Enter') { e.preventDefault(); toggle(); }
          });
          // keep switch in sync if checkbox changed externally
          cb.addEventListener('change', () => {
            if (cb.checked) sw.classList.add('on'); else sw.classList.remove('on');
            sw.setAttribute('aria-checked', cb.checked ? 'true' : 'false');
          });
          // append switch after the label or at end of row
          row.appendChild(sw);
        });
      } catch(e) {}
    })();
  </script>
</body>
</html>
